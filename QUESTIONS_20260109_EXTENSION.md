# Вопросы для обсуждения: Расширение функционала

**Date:** 2026-01-09  
**Status:** Open for Discussion  
**Related Tasks:**
- `task_20260109_edit_modes_xy.md` - Режимы редактирования X/Y
- `task_20260109_callback_api.md` - Callback API для внешних программ

---

## Задача 1: Режимы редактирования X/Y

### Q1.1: Расположение UI элементов
**Вопрос:** Где лучше разместить radio buttons для выбора режима редактирования?

**Варианты:**
- **A:** Рядом с dropdown выбора типа графика (columns/rows)
- **B:** В отдельной панели "Режим редактирования"
- **C:** В toolbar или меню

**Рекомендация:** Вариант A - рядом с другими настройками графика

**Решение:** ✅ Radio buttons уже созданы и размещены. Первая реализует режим XY, предусмотрены еще две (X и Y)

---

### Q1.2: Визуальная индикация ограничений
**Вопрос:** Нужна ли визуальная индикация ограничений на графике при перетаскивании?

**Варианты:**
- **A:** Показывать линию-ограничение (вертикальную для режима X, горизонтальную для Y)
- **B:** Только индикация в UI (radio buttons)
- **C:** Подсветка оси, по которой можно перемещать

**Рекомендация:** Вариант B для MVP, вариант A - будущее улучшение

**Решение:** ✅ **B:** Только индикация в UI (radio buttons)

---

### Q1.3: Поведение при переключении режима во время перетаскивания
**Вопрос:** Что должно происходить, если пользователь переключает режим во время активного перетаскивания?

**Варианты:**
- **A:** Завершить перетаскивание и начать новое с новым режимом
- **B:** Применить новый режим к текущему перетаскиванию
- **C:** Заблокировать переключение режима во время перетаскивания

**Рекомендация:** Вариант C - блокировать переключение во время перетаскивания

**Решение:** ✅ Пользователь сначала закончит перетаскивание, а потом нажмет radio button другого режима. Блокировка не требуется - пользователь сам контролирует процесс.

---

### Q1.4: Сохранение режима между сессиями
**Вопрос:** Должен ли режим редактирования сохраняться между сессиями работы с приложением?

**Варианты:**
- **A:** Да, сохранять в настройках приложения
- **B:** Нет, всегда начинать с режима XY
- **C:** Сохранять только в рамках одной сессии

**Рекомендация:** Вариант C - сохранять в рамках сессии, по умолчанию XY

**Решение:** ✅ **B:** Нет, всегда начинать с режима XY

---

## Задача 2: Callback API для внешних программ

### Q2.0: Сценарий использования
**Вопрос:** Какой сценарий использования Callback API?

**Ответ:** ✅ Сценарий использования:
- Внешняя программа работает с данными в Workspace
- Возникает необходимость изменения данных
- Внешняя программа вызывает TableGraphEditor через callback
- Пользователь корректирует данные в TableGraphEditor
- Данные сохраняются в Workspace
- TableGraphEditor закрывается
- Вызывается callback функция во внешней программе
- Внешняя программа продолжает работу с обновленными данными

**Требование:** TableGraphEditor должен быть вызываем как функция с callback параметром, который вызывается при сохранении или закрытии приложения.

---

### Q2.1: Формат callback функции
**Вопрос:** Какой формат callback функции?

**Решение:** ✅ Callback функция должна принимать:
- Имя переменной (строка)
- Обновленные данные (матрица)
- Флаг сохранения (true если данные сохранены, false если приложение закрыто без сохранения)

**Формат:** `callbackFunction(variableName, data, wasSaved)`

---

### Q2.2: Когда вызывать callback
**Вопрос:** В каких случаях вызывать callback?

**Решение:** ✅ Callback вызывается:
1. При сохранении данных (кнопка Save) - `wasSaved = true`
2. При закрытии приложения без сохранения - `wasSaved = false`
3. Опционально: при закрытии с сохранением через кнопку закрытия окна - зависит от реализации

---

### Q2.3: Способ вызова приложения
**Вопрос:** Как внешняя программа должна вызывать TableGraphEditor?

**Решение:** ✅ Создать wrapper функцию:
```matlab
app = editTableData(variableName, callbackFunction)
```
где:
- `variableName` - имя переменной в Workspace (строка)
- `callbackFunction` - function handle callback функции (опционально)
- `app` - объект приложения (для контроля, если нужно)

---

### Q2.4: Блокирующий vs неблокирующий режим
**Вопрос:** Должно ли приложение блокировать выполнение внешней программы?

**Решение:** ✅ Неблокирующий режим - приложение открывается, внешняя программа может продолжать работу (или ждать callback). Callback вызывается асинхронно при закрытии/сохранении.

---

## Общие вопросы

### Q3.1: Приоритет реализации
**Вопрос:** В каком порядке реализовывать задачи?

**Варианты:**
- **A:** Сначала режимы X/Y, потом Callback API
- **B:** Сначала Callback API, потом режимы X/Y
- **C:** Параллельно (если разные разработчики)

**Рекомендация:** Вариант A - режимы X/Y проще и не зависят от Callback API

**Решение:** [Ожидает обсуждения]

---

### Q3.2: Совместимость с существующим кодом
**Вопрос:** Нужна ли обратная совместимость с существующим кодом?

**Варианты:**
- **A:** Да, все существующие функции должны работать как раньше
- **B:** Допустимы небольшие изменения в API
- **C:** Можно изменить API, если это улучшает архитектуру

**Рекомендация:** Вариант A - обратная совместимость важна

**Решение:** [Ожидает обсуждения]

---

### Q3.3: Тестирование
**Вопрос:** Какой уровень тестирования требуется?

**Варианты:**
- **A:** Unit тесты для всех новых функций
- **B:** Unit тесты + интеграционные тесты
- **C:** Unit тесты + интеграционные тесты + ручное тестирование

**Рекомендация:** Вариант C - максимальная уверенность в качестве

**Решение:** [Ожидает обсуждения]

---

## Следующие шаги

После обсуждения и принятия решений:

1. Обновить задачи с принятыми решениями
2. Начать реализацию в соответствии с приоритетами
3. Обновить документацию по мере реализации

---

**Дата создания:** 2026-01-09  
**Последнее обновление:** 2026-01-10  
**Статус:** ✅ Все вопросы решены, задачи обновлены

